<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Symbolic Echo</title>
    
    <!-- PWA and Mobile App Tags -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Symbolic Echo">
    <link rel="apple-touch-icon" href="https://cdn-icons-png.flaticon.com/512/95/95240.png">
    <link rel="icon" href="https://cdn-icons-png.flaticon.com/512/95/95240.png">

    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Inter:wght@400;500&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
            -ms-user-select: none;
            overflow: hidden;
            margin: 0;
            background-color: #000; /* Solid black background */
        }
        #canvas-wrapper {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        #top-canvas {
            cursor: crosshair;
        }
    </style>
</head>
<body>

    <div id="canvas-wrapper">
        <!-- Bottom canvas for the symbols -->
        <canvas id="bottom-canvas"></canvas>
        <!-- Top canvas for the opaque cover and erasing -->
        <canvas id="top-canvas"></canvas>
    </div>

    <script>
        // --- Canvas and Context Setup ---
        const bottomCanvas = document.getElementById('bottom-canvas');
        const bottomCtx = bottomCanvas.getContext('2d');
        const topCanvas = document.getElementById('top-canvas');
        const topCtx = topCanvas.getContext('2d');

        // --- State Variables ---
        let isPointerDown = false; // Tracks if mouse/finger is down
        let hasDragged = false;    // Tracks if movement has occurred
        let startPos = { x: 0, y: 0 }; // Stores starting position of interaction
        const DRAG_THRESHOLD = 5;      // Min pixels to move to be considered a drag

        let isRevealed = false; 
        let protectedSymbolValue = null;
        const ERASER_SIZE = 35;
        const STORAGE_KEY = 'symbolicEchoProtected';
        let tapTimestamps = [];

        // --- Symbol Data ---
        const symbols = [
            { name: 'Circle', value: 1, draw: (c, x, y, s) => { c.arc(x, y, s * 0.35, 0, Math.PI * 2); } },
            { name: 'Cross', value: 2, draw: (c, x, y, s) => { c.moveTo(x, y - s * 0.35); c.lineTo(x, y + s * 0.35); c.moveTo(x - s * 0.35, y); c.lineTo(x + s * 0.35, y); } },
            { name: 'Wavy Lines', value: 3, draw: (c, x, y, s) => {
                for (let i = -1; i <= 1; i++) {
                    c.moveTo(x - s * 0.3, y + s * 0.2 * i);
                    c.quadraticCurveTo(x - s * 0.15, y + s * 0.2 * i - s * 0.2, x, y + s * 0.2 * i);
                    c.quadraticCurveTo(x + s * 0.15, y + s * 0.2 * i + s * 0.2, x + s * 0.3, y + s * 0.2 * i);
                }
            } },
            { name: 'Square', value: 4, draw: (c, x, y, s) => { c.rect(x - s * 0.35, y - s * 0.35, s * 0.7, s * 0.7); } },
            { name: 'Star', value: 5, draw: (c, x, y, s) => {
                c.moveTo(x, y - s * 0.35);
                for (let i = 1; i < 5; i++) {
                    c.lineTo(x + Math.sin(i * 0.8 * Math.PI) * s * 0.35, y - Math.cos(i * 0.8 * Math.PI) * s * 0.35);
                }
                c.closePath();
            } }
        ];

        let symbolStates = [];

        /**
         * Sets up both canvases.
         */
        function setupCanvases() {
            const dpr = window.devicePixelRatio || 1;
            const rect = topCanvas.getBoundingClientRect();
            
            topCanvas.width = rect.width * dpr;
            topCanvas.height = rect.height * dpr;
            topCtx.scale(dpr, dpr);

            bottomCanvas.width = rect.width * dpr;
            bottomCanvas.height = rect.height * dpr;
            bottomCtx.scale(dpr, dpr);
            
            loadState();
        }

        /**
         * Draws the symbols on the bottom canvas and defines their areas.
         */
        function drawSymbolsOnBottomCanvas() {
            // Set solid black background
            bottomCtx.fillStyle = '#000000';
            bottomCtx.fillRect(0, 0, bottomCanvas.width, bottomCanvas.height);
            
            bottomCtx.strokeStyle = '#e0e0e0';
            bottomCtx.lineWidth = Math.min(bottomCanvas.clientWidth, bottomCanvas.clientHeight) / 100;
            bottomCtx.lineCap = 'round';
            
            const gridSize = 3;
            const minDim = Math.min(bottomCanvas.clientWidth, bottomCanvas.clientHeight);
            const cellSize = minDim / gridSize;
            const symbolSize = cellSize * 0.8;
            
            const offsetX = (bottomCanvas.clientWidth - minDim) / 2;
            const offsetY = (bottomCanvas.clientHeight - minDim) / 2;

            const positions = [
                { row: 0, col: 0 }, { row: 0, col: 2 },
                { row: 2, col: 0 }, { row: 2, col: 2 },
                { row: 1, col: 1 }
            ];

            symbolStates.forEach((state, i) => {
                const symbol = symbols[i];
                const x = offsetX + (positions[i].col + 0.5) * cellSize;
                const y = offsetY + (positions[i].row + 0.5) * cellSize;
                
                state.bounds = {
                    x: x - cellSize / 2, y: y - cellSize / 2,
                    width: cellSize, height: cellSize
                };
                
                bottomCtx.beginPath();
                symbol.draw(bottomCtx, x, y, symbolSize);
                bottomCtx.stroke();
            });
        }

        /**
         * Resets the board to its initial state.
         */
        function resetBoard() {
            isRevealed = false;
            protectedSymbolValue = null;
            symbolStates = symbols.map(s => ({ 
                value: s.value, 
                touched: false,
                bounds: {} 
            }));
            
            drawSymbolsOnBottomCanvas();
            
            // Make the top canvas fully transparent
            topCtx.clearRect(0, 0, topCanvas.width, topCanvas.height);
        }

        /**
         * Loads state from localStorage to see if the app is in "decoy" mode.
         */
        function loadState() {
            const savedValue = localStorage.getItem(STORAGE_KEY);
            resetBoard(); // Start with a fresh board
            if (savedValue) {
                // If there's a saved value, enter decoy mode immediately.
                isRevealed = true;
                protectedSymbolValue = parseInt(savedValue, 10);
            }
        }

        /**
         * Covers a portion of the top canvas by drawing a black stroke.
         */
        function coverWithStroke(x, y) {
            // Check if the eraser is over the protected symbol's area
            if (isRevealed) {
                const protectedSymbol = symbolStates.find(s => s.value === protectedSymbolValue);
                if (protectedSymbol) {
                    const b = protectedSymbol.bounds;
                    if (x > b.x && x < b.x + b.width && y > b.y && y < b.y + b.height) {
                        return; // Do not draw if over the protected symbol
                    }
                }
            }
            
            topCtx.fillStyle = '#000000';
            topCtx.beginPath();
            topCtx.arc(x, y, ERASER_SIZE, 0, Math.PI * 2, false);
            topCtx.fill();
        }

        /**
         * Checks if the stroke has entered a symbol's area and marks it.
         */
        function checkTouch(x, y) {
            if (isRevealed) return; // Don't check for new touches after reveal

            symbolStates.forEach(state => {
                const b = state.bounds;
                if (x > b.x && x < b.x + b.width && y > b.y && y < b.y + b.height) {
                    state.touched = true;
                }
            });

            const touchedSymbols = symbolStates.filter(s => s.touched);
            if (touchedSymbols.length === 4) {
                const untouchedSymbol = symbolStates.find(s => !s.touched);
                if (untouchedSymbol) {
                    protectedSymbolValue = untouchedSymbol.value;
                    isRevealed = true; // Lock the reveal logic
                    // Save the secret to local storage
                    localStorage.setItem(STORAGE_KEY, protectedSymbolValue.toString());
                }
            }
        }

        /**
         * Handles the secret tap mechanism to reset the stored data.
         */
        function handleSecretReset() {
            const now = new Date().getTime();
            tapTimestamps.push(now);
            // Keep only taps from the last 2 seconds
            tapTimestamps = tapTimestamps.filter(timestamp => now - timestamp < 2000);
            if (tapTimestamps.length >= 3) {
                localStorage.removeItem(STORAGE_KEY);
                tapTimestamps = []; // Reset taps
                // Briefly flash the screen to confirm reset
                document.body.style.backgroundColor = 'white';
                setTimeout(() => {
                    document.body.style.backgroundColor = 'black';
                    loadState(); // Reload the state to normal mode
                }, 100);
            }
        }

        // --- Event Listeners ---
        function handleStart(e) {
            isPointerDown = true;
            hasDragged = false;
            startPos = getPos(e);
        }

        function handleMove(e) {
            if (!isPointerDown) return;
            e.preventDefault();
            
            const currentPos = getPos(e);
            const distance = Math.hypot(currentPos.x - startPos.x, currentPos.y - startPos.y);

            // Only start drawing if the pointer has moved beyond the threshold
            if (distance > DRAG_THRESHOLD) {
                hasDragged = true;
            }

            if (hasDragged) {
                coverWithStroke(currentPos.x, currentPos.y);
                checkTouch(currentPos.x, currentPos.y);
            }
        }

        function handleEnd() {
            if (!isPointerDown) return;

            // If there was no significant drag, it's a tap.
            if (!hasDragged) {
                handleSecretReset();
            }
            
            isPointerDown = false;
        }

        function getPos(e) {
            const rect = topCanvas.getBoundingClientRect();
            const clientX = e.clientX || e.touches[0].clientX;
            const clientY = e.clientY || e.touches[0].clientY;
            return {
                x: clientX - rect.left,
                y: clientY - rect.top
            };
        }

        // Mouse Events
        window.addEventListener('mousedown', handleStart);
        window.addEventListener('mousemove', handleMove);
        window.addEventListener('mouseup', handleEnd);
        window.addEventListener('mouseleave', handleEnd);

        // Touch Events
        window.addEventListener('touchstart', handleStart, { passive: false });
        window.addEventListener('touchmove', handleMove, { passive: false });
        window.addEventListener('touchend', handleEnd);
        window.addEventListener('touchcancel', handleEnd);

        window.addEventListener('resize', setupCanvases);

        // --- Initialize ---
        setupCanvases();

    </script>
</body>
</html>
