<!DOCTYPE html>

<html lang="en">

<head>

    <meta charset="UTF-8">

    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">

    <title>ESP Symbol Online</title>

    

    <!-- PWA and Mobile App Tags -->

    <meta name="apple-mobile-web-app-capable" content="yes">

    <meta name="mobile-web-app-capable" content="yes">

    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

    <meta name="apple-mobile-web-app-title" content="ESP">

    <link rel="apple-touch-icon" href="https://cdn-icons-png.flaticon.com/512/95/95240.png">

    <link rel="icon" href="https://cdn-icons-png.flaticon.com/512/95/95240.png">


    <script src="https://cdn.tailwindcss.com"></script>

    <link rel="preconnect" href="https://fonts.googleapis.com">

    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>

    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Inter:wght@400;500&display=swap" rel="stylesheet">

    <style>

        body {

            font-family: 'Inter', sans-serif;

            touch-action: none;

            user-select: none;

            -webkit-user-select: none;

            -ms-user-select: none;

            overflow: hidden;

            margin: 0;

            background-color: #000; /* Solid black background */

        }

        #canvas-wrapper {

            position: relative;

            width: 100vw;

            height: 100vh;

        }

        canvas {

            position: absolute;

            top: 0;

            left: 0;

            width: 100%;

            height: 100%;

        }

        #top-canvas {

            cursor: crosshair;

        }

    </style>

</head>

<body>


    <div id="canvas-wrapper">

        <!-- Bottom canvas for the symbols -->

        <canvas id="bottom-canvas"></canvas>

        <!-- Top canvas for the opaque cover and erasing -->

        <canvas id="top-canvas"></canvas>

    </div>


    <script>

        // --- Canvas and Context Setup ---

        const bottomCanvas = document.getElementById('bottom-canvas');

        const bottomCtx = bottomCanvas.getContext('2d');

        const topCanvas = document.getElementById('top-canvas');

        const topCtx = topCanvas.getContext('2d');


        // --- State Variables ---

        let isPointerDown = false; // Tracks if mouse/finger is down

        let hasDragged = false;    // Tracks if movement has occurred

        let startPos = { x: 0, y: 0 }; // Stores starting position of interaction

        const DRAG_THRESHOLD = 5;      // Min pixels to move to be considered a drag


        let isRevealed = false; 

        let protectedSymbolValue = null;

        const ERASER_SIZE = 35;

        const STORAGE_KEY = 'symbolicEchoProtected';

        let tapTimestamps = [];


        // --- Symbol Data ---

        const symbols = [

            { name: 'Circle', value: 1, draw: (c, x, y, s) => { c.arc(x, y, s * 0.35, 0, Math.PI * 2); } },

            { name: 'Cross', value: 2, draw: (c, x, y, s) => { c.moveTo(x, y - s * 0.35); c.lineTo(x, y + s * 0.35); c.moveTo(x - s * 0.35, y); c.lineTo(x + s * 0.35, y); } },

            { name: 'Wavy Lines', value: 3, draw: (c, x, y, s) => {

                for (let i = -1; i <= 1; i++) {

                    c.moveTo(x - s * 0.3, y + s * 0.2 * i);

                    c.quadraticCurveTo(x - s * 0.15, y + s * 0.2 * i - s * 0.2, x, y + s * 0.2 * i);

                    c.quadraticCurveTo(x + s * 0.15, y + s * 0.2 * i + s * 0.2, x + s * 0.3, y + s * 0.2 * i);

                }

            } },

            { name: 'Square', value: 4, draw: (c, x, y, s) => { c.rect(x - s * 0.35, y - s * 0.35, s * 0.7, s * 0.7); } },

            { name: 'Star', value: 5, draw: (c, x, y, s) => {

                c.moveTo(x, y - s * 0.35);

                for (let i = 1; i < 5; i++) {

                    c.lineTo(x + Math.sin(i * 0.8 * Math.PI) * s * 0.35, y - Math.cos(i * 0.8 * Math.PI) * s * 0.35);

                }

                c.closePath();

            } }

        ];


        let symbolStates = [];


        /**

         * Sets up both canvases.

         */

        function setupCanvases() {

            const dpr = window.devicePixelRatio || 1;

            const rect = topCanvas.getBoundingClientRect();

            

            topCanvas.width = rect.width * dpr;

            topCanvas.height = rect.height * dpr;

            topCtx.scale(dpr, dpr);


            bottomCanvas.width = rect.width * dpr;

            bottomCanvas.height = rect.height * dpr;

            bottomCtx.scale(dpr, dpr);

            

            loadState();

        }


        /**

         * Draws the symbols and vignette on the bottom canvas.

         */

        function drawSymbolsOnBottomCanvas() {

            const centerX = bottomCanvas.clientWidth / 2;

            const centerY = bottomCanvas.clientHeight / 2;

            const outerRadius = Math.sqrt(centerX * centerX + centerY * centerY);


            const gradient = bottomCtx.createRadialGradient(centerX, centerY, 0, centerX, centerY, outerRadius);

            gradient.addColorStop(0, '#1a1a1a'); // Dark gray center

            gradient.addColorStop(1, '#000000'); // Black edges


            bottomCtx.fillStyle = gradient;

            bottomCtx.fillRect(0, 0, bottomCanvas.clientWidth, bottomCanvas.clientHeight);

            

            bottomCtx.strokeStyle = '#e0e0e0';

            bottomCtx.lineWidth = Math.min(bottomCanvas.clientWidth, bottomCanvas.clientHeight) / 100;

            bottomCtx.lineCap = 'round';

            

            const gridSize = 3;

            const minDim = Math.min(bottomCanvas.clientWidth, bottomCanvas.clientHeight);

            const cellSize = minDim / gridSize;

            const symbolSize = cellSize * 0.8;

            

            const offsetX = (bottomCanvas.clientWidth - minDim) / 2;

            const offsetY = (bottomCanvas.clientHeight - minDim) / 2;


            const positions = [

                { row: 0, col: 0 }, { row: 0, col: 2 },

                { row: 2, col: 0 }, { row: 2, col: 2 },

                { row: 1, col: 1 }

            ];


            symbolStates.forEach((state, i) => {

                const symbol = symbols[i];

                const x = offsetX + (positions[i].col + 0.5) * cellSize;

                const y = offsetY + (positions[i].row + 0.5) * cellSize;

                

                state.bounds = {

                    x: x - cellSize / 2, y: y - cellSize / 2,

                    width: cellSize, height: cellSize

                };

                

                bottomCtx.beginPath();

                symbol.draw(bottomCtx, x, y, symbolSize);

                bottomCtx.stroke();

            });

        }


        /**

         * Resets the board to its initial state.

         */

        function resetBoard() {

            isRevealed = false;

            protectedSymbolValue = null;

            symbolStates = symbols.map(s => ({ 

                value: s.value, 

                touched: false,

                bounds: {} 

            }));

            

            drawSymbolsOnBottomCanvas();

            

            // Make the top canvas fully transparent

            topCtx.clearRect(0, 0, topCanvas.width, topCanvas.height);

        }


        /**

         * Loads state from localStorage to see if the app is in "decoy" mode.

         */

        function loadState() {

            const savedValue = localStorage.getItem(STORAGE_KEY);

            resetBoard(); // Start with a fresh board

            if (savedValue) {

                isRevealed = true;

                protectedSymbolValue = parseInt(savedValue, 10);

            }

        }


        /**

         * Covers a portion of the top canvas by drawing a stroke that matches the vignette.

         */

        function coverWithStroke(x, y) {

            if (isRevealed) {

                const protectedSymbol = symbolStates.find(s => s.value === protectedSymbolValue);

                if (protectedSymbol) {

                    const b = protectedSymbol.bounds;

                    const closestX = Math.max(b.x, Math.min(x, b.x + b.width));

                    const closestY = Math.max(b.y, Math.min(y, b.y + b.height));

                    const distance = Math.hypot(x - closestX, y - closestY);

                    if (distance < ERASER_SIZE) {

                        return;

                    }

                }

            }

            

            // Create a gradient that matches the bottom canvas for the stroke

            const centerX = topCanvas.clientWidth / 2;

            const centerY = topCanvas.clientHeight / 2;

            const outerRadius = Math.sqrt(centerX * centerX + centerY * centerY);

            const gradient = topCtx.createRadialGradient(centerX, centerY, 0, centerX, centerY, outerRadius);

            gradient.addColorStop(0, '#1a1a1a');

            gradient.addColorStop(1, '#000000');

            

            topCtx.fillStyle = gradient;

            topCtx.beginPath();

            topCtx.arc(x, y, ERASER_SIZE, 0, Math.PI * 2, false);

            topCtx.fill();

        }


        /**

         * Checks if the stroke has entered a symbol's area and marks it.

         */

        function checkTouch(x, y) {

            if (isRevealed) return;


            symbolStates.forEach(state => {

                const b = state.bounds;

                if (x > b.x && x < b.x + b.width && y > b.y && y < b.y + b.height) {

                    state.touched = true;

                }

            });


            const touchedSymbols = symbolStates.filter(s => s.touched);

            if (touchedSymbols.length === 4) {

                const untouchedSymbol = symbolStates.find(s => !s.touched);

                if (untouchedSymbol) {

                    protectedSymbolValue = untouchedSymbol.value;

                    isRevealed = true;

                    localStorage.setItem(STORAGE_KEY, protectedSymbolValue.toString());

                }

            }

        }


        /**

         * Handles the secret tap mechanism to reset the stored data.

         */

        function handleSecretReset() {

            const now = new Date().getTime();

            tapTimestamps.push(now);

            tapTimestamps = tapTimestamps.filter(timestamp => now - timestamp < 2000);

            if (tapTimestamps.length >= 3) {

                localStorage.removeItem(STORAGE_KEY);

                tapTimestamps = [];

                document.body.style.backgroundColor = 'white';

                setTimeout(() => {

                    document.body.style.backgroundColor = 'black';

                    loadState();

                }, 100);

            }

        }


        // --- Event Listeners ---

        function handleStart(e) {

            isPointerDown = true;

            hasDragged = false;

            startPos = getPos(e);


            const currentPos = getPos(e);

            checkTouch(currentPos.x, currentPos.y);

            coverWithStroke(currentPos.x, currentPos.y);

        }


        function handleMove(e) {

            if (!isPointerDown) return;

            e.preventDefault();

            

            const currentPos = getPos(e);

            const distance = Math.hypot(currentPos.x - startPos.x, currentPos.y - startPos.y);


            if (distance > DRAG_THRESHOLD) {

                hasDragged = true;

            }


            checkTouch(currentPos.x, currentPos.y);

            coverWithStroke(currentPos.x, currentPos.y);

        }


        function handleEnd() {

            if (!isPointerDown) return;


            if (!hasDragged) {

                handleSecretReset();

            }

            

            isPointerDown = false;

        }


        function getPos(e) {

            const rect = topCanvas.getBoundingClientRect();

            const clientX = e.clientX || e.touches[0].clientX;

            const clientY = e.clientY || e.touches[0].clientY;

            return {

                x: clientX - rect.left,

                y: clientY - rect.top

            };

        }


        // Mouse Events

        window.addEventListener('mousedown', handleStart);

        window.addEventListener('mousemove', handleMove);

        window.addEventListener('mouseup', handleEnd);

        window.addEventListener('mouseleave', handleEnd);


        // Touch Events

        window.addEventListener('touchstart', handleStart, { passive: false });

        window.addEventListener('touchmove', handleMove, { passive: false });

        window.addEventListener('touchend', handleEnd);

        window.addEventListener('touchcancel', handleEnd);


        window.addEventListener('resize', setupCanvases);


        // --- Initialize ---

        setupCanvases();


    </script>

</body>

</html>


